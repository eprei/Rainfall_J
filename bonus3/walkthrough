so i try to launch the program 
./bonus3

but is make nothgin 

so when i try to watch the code is look like that :


.text:080484F4                 public main
.text:080484F4 main            proc near               ; DATA XREF: _start+17↑o
.text:080484F4
.text:080484F4 var_4F          = byte ptr -4Fh
.text:080484F4 anonymous_0     = dword ptr -0Ch
.text:080484F4 argc            = dword ptr  8
.text:080484F4 argv            = dword ptr  0Ch
.text:080484F4 envp            = dword ptr  10h
.text:080484F4
.text:080484F4 ; __unwind {
.text:080484F4                 push    ebp
.text:080484F5                 mov     ebp, esp
.text:080484F7                 push    edi
.text:080484F8                 push    ebx
.text:080484F9                 and     esp, 0FFFFFFF0h
.text:080484FC                 sub     esp, 160
.text:08048502                 mov     edx, offset unk_80486F0
.text:08048507                 mov     eax, offset aHomeUserEndPas ; "/home/user/end/.pass"
.text:0804850C                 mov     [esp+4], edx
.text:08048510                 mov     [esp], eax
.text:08048513                 call    _fopen
.text:08048518                 mov     [esp+156], eax
.text:0804851F                 lea     ebx, [esp+24]
.text:08048523                 mov     eax, 0
.text:08048528                 mov     edx, 33
.text:0804852D                 mov     edi, ebx
.text:0804852F                 mov     ecx, edx
.text:08048531                 rep stosd
.text:08048533                 cmp     dword ptr [esp+156], 0
.text:0804853B                 jz      short loc_8048543
.text:0804853D                 cmp     [ebp+argc], 2
.text:08048541                 jz      short loc_804854D
.text:08048543
.text:08048543 loc_8048543:                            ; CODE XREF: main+47↑j
.text:08048543                 mov     eax, 4294967295
.text:08048548                 jmp     loc_8048615
.text:0804854D ; ---------------------------------------------------------------------------
.text:0804854D
.text:0804854D loc_804854D:                            ; CODE XREF: main+4D↑j
.text:0804854D                 lea     eax, [esp+24]
.text:08048551                 mov     edx, [esp+156]
.text:08048558                 mov     [esp+0Ch], edx
.text:0804855C                 mov     dword ptr [esp+8], 66
.text:08048564                 mov     dword ptr [esp+4], 1
.text:0804856C                 mov     [esp], eax
.text:0804856F                 call    _fread
.text:08048574                 mov     byte ptr [esp+89], 0
.text:08048579                 mov     eax, [ebp+argv]
.text:0804857C                 add     eax, 4
.text:0804857F                 mov     eax, [eax]
.text:08048581                 mov     [esp], eax
.text:08048584                 call    _atoi
.text:08048589                 mov     byte ptr [esp+eax+24], 0
.text:0804858E                 lea     eax, [esp+18h]
.text:08048592                 lea     edx, [eax+42h]
.text:08048595                 mov     eax, [esp+9Ch]
.text:0804859C                 mov     [esp+0Ch], eax
.text:080485A0                 mov     dword ptr [esp+8], 41h ; 'A'
.text:080485A8                 mov     dword ptr [esp+4], 1
.text:080485B0                 mov     [esp], edx
.text:080485B3                 call    _fread
.text:080485B8                 mov     eax, [esp+9Ch]
.text:080485BF                 mov     [esp], eax
.text:080485C2                 call    _fclose
.text:080485C7                 mov     eax, [ebp+argv]
.text:080485CA                 add     eax, 4
.text:080485CD                 mov     eax, [eax]
.text:080485CF                 mov     [esp+4], eax
.text:080485D3                 lea     eax, [esp+18h]
.text:080485D7                 mov     [esp], eax
.text:080485DA                 call    _strcmp
.text:080485DF                 test    eax, eax
.text:080485E1                 jnz     short loc_8048601
.text:080485E3                 mov     dword ptr [esp+8], 0
.text:080485EB                 mov     dword ptr [esp+4], offset aSh ; "sh"
.text:080485F3                 mov     dword ptr [esp], offset aBinSh ; "/bin/sh"
.text:080485FA                 call    _execl
.text:080485FF                 jmp     short loc_8048610
.text:08048601 ; ---------------------------------------------------------------------------
.text:08048601
.text:08048601 loc_8048601:                            ; CODE XREF: main+ED↑j
.text:08048601                 lea     eax, [esp+18h]
.text:08048605                 add     eax, 42h ; 'B'
.text:08048608                 mov     [esp], eax
.text:0804860B                 call    _puts
.text:08048610
.text:08048610 loc_8048610:                            ; CODE XREF: main+10B↑j
.text:08048610                 mov     eax, 0
.text:08048615
.text:08048615 loc_8048615:                            ; CODE XREF: main+54↑j
.text:08048615                 lea     esp, [ebp-8]
.text:08048618                 pop     ebx
.text:08048619                 pop     edi
.text:0804861A                 pop     ebp
.text:0804861B                 retn
.text:0804861B ; } // starts at 80484F4
.text:0804861B main            endp
.text:0804861B


and the pseudo code in c :

int __cdecl main(int argc, const char **argv, const char **envp)
{
  _BYTE v4[132]; // [esp+18h] [ebp-90h] BYREF
  int v5; // [esp+9Ch] [ebp-Ch]

  v5 = fopen("/home/user/end/.pass", &unk_80486F0);
  memset(v4, 0, sizeof(v4));
  if ( !v5 || argc != 2 )
    return -1;
  fread(v4, 1, 66, v5);
  v4[65] = 0;
  v4[atoi(argv[1])] = 0;
  fread(&v4[66], 1, 65, v5);
  fclose(v5);
  if ( !strcmp(v4, argv[1]) )
    execl("/bin/sh", "sh", 0);
  else
    puts(&v4[66]);
  return 0;
}



so is open the file in /home/user/end/.pass and put the content inside 
the buffer of 132 octet 
.text:08048502                 mov     edx, offset unk_80486F0
.text:08048507                 mov     eax, offset aHomeUserEndPas ; "/home/user/end/.pass"
.text:0804850C                 mov     [esp+4], edx
.text:08048510                 mov     [esp], eax
.text:08048513                 call    _fopen
.text:08048518                 mov     [esp+156], eax



after is read 66 octet from the file and store inside the buffer
.text:0804851F                 lea     ebx, [esp+24]
.text:0804854D                 lea     eax, [esp+24]
.text:08048551                 mov     edx, [esp+156]
.text:08048558                 mov     [esp+0Ch], edx
.text:0804855C                 mov     dword ptr [esp+8], 66
.text:08048564                 mov     dword ptr [esp+4], 1
.text:0804856C                 mov     [esp], eax
.text:0804856F                 call    _fread


is put the \0 inside the octet 89 of the buffer
.text:08048574                 mov     byte ptr [esp+89], 0

after is get the first arugmnet and call atoi to get the value of the argument in int
.text:08048579                 mov     eax, [ebp+argv]
.text:0804857C                 add     eax, 4
.text:0804857F                 mov     eax, [eax]
.text:08048581                 mov     [esp], eax
.text:08048584                 call    _atoi


after at addres of the eax is put the value 0
.text:08048589                 mov     byte ptr [esp+eax+24], 0


after is call fread with the paramter 
ptr is point to eax+42h 
size to 1
nmemb to 41
stream to the file

read from the file 65 octet 

.text:0804858E                 lea     eax, [esp+18h]
.text:08048592                 lea     edx, [eax+42h]
.text:08048595                 mov     eax, [esp+9Ch]
.text:0804859C                 mov     [esp+0Ch], eax
.text:080485A0                 mov     dword ptr [esp+8], 41h ; 'A'
.text:080485A8                 mov     dword ptr [esp+4], 1
.text:080485B0                 mov     [esp], edx
.text:080485B3                 call    _fread


after is close the file:
.text:080485B8                 mov     eax, [esp+9Ch]
.text:080485BF                 mov     [esp], eax
.text:080485C2                 call    _fclose


and compare the value of ebp + 18h and argv and compare if no difference
.text:080485C7                 mov     eax, [ebp+argv]
.text:080485CA                 add     eax, 4
.text:080485CD                 mov     eax, [eax]
.text:080485CF                 mov     [esp+4], eax
.text:080485D3                 lea     eax, [esp+18h]
.text:080485D7                 mov     [esp], eax
.text:080485DA                 call    _strcmp

if now differnce is start a shell
.text:080485DF                 test    eax, eax



.text:080485E1                 jnz     short loc_8048601
.text:080485E3                 mov     dword ptr [esp+8], 0
.text:080485EB                 mov     dword ptr [esp+4], offset aSh ; "sh"
.text:080485F3                 mov     dword ptr [esp], offset aBinSh ; "/bin/sh"
.text:080485FA                 call    _execl


if now is write the 66 element of the buffer in stdout
.text:080485FF                 jmp     short loc_8048610
.text:08048601 ; ---------------------------------------------------------------------------
.text:08048601
.text:08048601 loc_8048601:                            ; CODE XREF: main+ED↑j
.text:08048601                 lea     eax, [esp+18h]
.text:08048605                 add     eax, 42h ;
.text:08048608                 mov     [esp], eax
.text:0804860B                 call    _puts


so how to exploit 
if you put a string inside atoi 
is return 0 


so if i put 0x0 is return 0 and is make a empty string 

after is compare this empty string with the argument 0x0 so is true 

and get the flag !!

3321b6f81659f9a71c76616f606e4b50189cecfea611393d5d649f75e157353c

